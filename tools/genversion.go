// Copyright (c) 2012-2016 Eli Janssen
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file.

package main

import (
	"bufio"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path"
	"regexp"
	"strings"
	"text/template"
)

// VersionLicenseText is a text formatter container
type VersionLicenseText struct {
	Text string
	Pkg  string
}

const tplText = `
// Copyright (c) 2012-2016 Eli Janssen
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file.

// THIS FILE IS AUTOGENERATED. DO NOT EDIT!

package {{.Pkg}}

const licenseText = ` + "`{{.Text}}`"

func main() {
	var output, input, pkg string
	flag.StringVar(&output, "output", "", "output file")
	flag.StringVar(&input, "input", "", "input file")
	flag.StringVar(&pkg, "pkg", "", "package name")
	flag.Parse()

	if input == "" {
		log.Fatal("Input option is required")
	}

	if output == "" {
		log.Fatal("Output option is required")
	}

	if pkg == "" {
		log.Fatal("Package option is required")
	}

	fmt.Printf("Generating %s based on %s\n", path.Base(output), path.Base(input))

	t, err := template.New("fileTemplate").Parse(strings.TrimSpace(tplText))
	if err != nil {
		log.Fatal(err)
	}

	b, err := ioutil.ReadFile(input)
	if err != nil {
		log.Fatal(err)
	}

	reTildes := regexp.MustCompile("(?m:^~~~.*\n?$)")
	reComment := regexp.MustCompile("(?m:^//.*\n?$)")
	inputText := string(b)
	inputText = reTildes.ReplaceAllLiteralString(inputText, "")
	inputText = reComment.ReplaceAllLiteralString(inputText, "")

	f, err := os.Create(output)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	writer := bufio.NewWriter(f)
	defer writer.Flush()

	data := &VersionLicenseText{
		Text: inputText,
		Pkg:  pkg,
	}

	err = t.Execute(writer, data)
	if err != nil {
		log.Fatal(err)
	}
}
